"""
A floating point number that requires more precision than IEEE 754 binary 64
"""
scalar BigFloat

"""All input for the `createConstraintIfNotExists` mutation."""
input CreateConstraintIfNotExistsInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  tSchema: String
  tName: String
  cName: String
  constraintSql: String
}

"""The output of our `createConstraintIfNotExists` mutation."""
type CreateConstraintIfNotExistsPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the create `Meta` mutation."""
input CreateMetaInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Meta` to be created by this mutation."""
  meta: MetaInput!
}

"""The output of our create `Meta` mutation."""
type CreateMetaPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Meta` that was created by this mutation."""
  meta: Meta

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the create `Player` mutation."""
input CreatePlayerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Player` to be created by this mutation."""
  player: PlayerInput!
}

"""The output of our create `Player` mutation."""
type CreatePlayerPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Player` that was created by this mutation."""
  player: Player

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the create `PlayerStat` mutation."""
input CreatePlayerStatInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `PlayerStat` to be created by this mutation."""
  playerStat: PlayerStatInput!
}

"""The output of our create `PlayerStat` mutation."""
type CreatePlayerStatPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `PlayerStat` that was created by this mutation."""
  playerStat: PlayerStat

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the create `UserAccount` mutation."""
input CreateUserAccountInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `UserAccount` to be created by this mutation."""
  userAccount: UserAccountInput!
}

"""The output of our create `UserAccount` mutation."""
type CreateUserAccountPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `UserAccount` that was created by this mutation."""
  userAccount: UserAccount

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
A point in time as described by the [ISO
8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
"""
scalar Datetime

"""All input for the `deleteMetaByReplayId` mutation."""
input DeleteMetaByReplayIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  replayId: String!
}

"""All input for the `deleteMeta` mutation."""
input DeleteMetaInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Meta` to be deleted.
  """
  nodeId: ID!
}

"""The output of our delete `Meta` mutation."""
type DeleteMetaPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Meta` that was deleted by this mutation."""
  meta: Meta
  deletedMetaId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `deletePlayerByPlayerId` mutation."""
input DeletePlayerByPlayerIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  playerId: String!
}

"""All input for the `deletePlayer` mutation."""
input DeletePlayerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Player` to be deleted.
  """
  nodeId: ID!
}

"""The output of our delete `Player` mutation."""
type DeletePlayerPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Player` that was deleted by this mutation."""
  player: Player
  deletedPlayerId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `deletePlayerStatByReplayIdAndPlayerName` mutation."""
input DeletePlayerStatByReplayIdAndPlayerNameInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  replayId: String!
  playerName: String!
}

"""All input for the `deletePlayerStat` mutation."""
input DeletePlayerStatInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `PlayerStat` to be deleted.
  """
  nodeId: ID!
}

"""The output of our delete `PlayerStat` mutation."""
type DeletePlayerStatPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `PlayerStat` that was deleted by this mutation."""
  playerStat: PlayerStat
  deletedPlayerStatId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `deleteUserAccountByUserId` mutation."""
input DeleteUserAccountByUserIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """Primary unique identifier for a user. Autogenerated."""
  userId: UUID!
}

"""All input for the `deleteUserAccountByUsername` mutation."""
input DeleteUserAccountByUsernameInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The user’s username. Can be null."""
  username: String!
}

"""All input for the `deleteUserAccount` mutation."""
input DeleteUserAccountInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `UserAccount` to be deleted.
  """
  nodeId: ID!
}

"""The output of our delete `UserAccount` mutation."""
type DeleteUserAccountPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `UserAccount` that was deleted by this mutation."""
  userAccount: UserAccount
  deletedUserAccountId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

input LoginInput {
  username: String!
  password: String!
}

type LoginPayload {
  user: UserAccount!
}

type Meta implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  replayDate: String!
  replayId: String!
  mapName: String
  serverName: String
  team0Score: Int
  team1Score: Int
  replayLength: String
}

"""
A condition to be used against `Meta` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input MetaCondition {
  """Checks for equality with the object’s `replayId` field."""
  replayId: String
}

"""An input for mutations affecting `Meta`"""
input MetaInput {
  replayDate: String!
  replayId: String!
  mapName: String
  serverName: String
  team0Score: Int
  team1Score: Int
  replayLength: String
}

"""Represents an update to a `Meta`. Fields that are set will be updated."""
input MetaPatch {
  replayDate: String
  replayId: String
  mapName: String
  serverName: String
  team0Score: Int
  team1Score: Int
  replayLength: String
}

"""Methods to use when ordering `Meta`."""
enum MetasOrderBy {
  NATURAL
  REPLAY_ID_ASC
  REPLAY_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
The root mutation type which contains root level fields which mutate data.
"""
type Mutation {
  """Creates a single `UserAccount`."""
  createUserAccount(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateUserAccountInput!
  ): CreateUserAccountPayload

  """Creates a single `Meta`."""
  createMeta(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateMetaInput!
  ): CreateMetaPayload

  """Creates a single `Player`."""
  createPlayer(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreatePlayerInput!
  ): CreatePlayerPayload

  """Creates a single `PlayerStat`."""
  createPlayerStat(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreatePlayerStatInput!
  ): CreatePlayerStatPayload

  """
  Updates a single `UserAccount` using its globally unique id and a patch.
  """
  updateUserAccount(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateUserAccountInput!
  ): UpdateUserAccountPayload

  """Updates a single `UserAccount` using a unique key and a patch."""
  updateUserAccountByUserId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateUserAccountByUserIdInput!
  ): UpdateUserAccountPayload

  """Updates a single `UserAccount` using a unique key and a patch."""
  updateUserAccountByUsername(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateUserAccountByUsernameInput!
  ): UpdateUserAccountPayload

  """Updates a single `Meta` using its globally unique id and a patch."""
  updateMeta(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateMetaInput!
  ): UpdateMetaPayload

  """Updates a single `Meta` using a unique key and a patch."""
  updateMetaByReplayId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateMetaByReplayIdInput!
  ): UpdateMetaPayload

  """Updates a single `Player` using its globally unique id and a patch."""
  updatePlayer(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePlayerInput!
  ): UpdatePlayerPayload

  """Updates a single `Player` using a unique key and a patch."""
  updatePlayerByPlayerId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePlayerByPlayerIdInput!
  ): UpdatePlayerPayload

  """
  Updates a single `PlayerStat` using its globally unique id and a patch.
  """
  updatePlayerStat(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePlayerStatInput!
  ): UpdatePlayerStatPayload

  """Updates a single `PlayerStat` using a unique key and a patch."""
  updatePlayerStatByReplayIdAndPlayerName(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePlayerStatByReplayIdAndPlayerNameInput!
  ): UpdatePlayerStatPayload

  """Deletes a single `UserAccount` using its globally unique id."""
  deleteUserAccount(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteUserAccountInput!
  ): DeleteUserAccountPayload

  """Deletes a single `UserAccount` using a unique key."""
  deleteUserAccountByUserId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteUserAccountByUserIdInput!
  ): DeleteUserAccountPayload

  """Deletes a single `UserAccount` using a unique key."""
  deleteUserAccountByUsername(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteUserAccountByUsernameInput!
  ): DeleteUserAccountPayload

  """Deletes a single `Meta` using its globally unique id."""
  deleteMeta(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteMetaInput!
  ): DeleteMetaPayload

  """Deletes a single `Meta` using a unique key."""
  deleteMetaByReplayId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteMetaByReplayIdInput!
  ): DeleteMetaPayload

  """Deletes a single `Player` using its globally unique id."""
  deletePlayer(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeletePlayerInput!
  ): DeletePlayerPayload

  """Deletes a single `Player` using a unique key."""
  deletePlayerByPlayerId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeletePlayerByPlayerIdInput!
  ): DeletePlayerPayload

  """Deletes a single `PlayerStat` using its globally unique id."""
  deletePlayerStat(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeletePlayerStatInput!
  ): DeletePlayerStatPayload

  """Deletes a single `PlayerStat` using a unique key."""
  deletePlayerStatByReplayIdAndPlayerName(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeletePlayerStatByReplayIdAndPlayerNameInput!
  ): DeletePlayerStatPayload
  createConstraintIfNotExists(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateConstraintIfNotExistsInput!
  ): CreateConstraintIfNotExistsPayload

  """Register`s a user account, with a username."""
  registerUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: RegisterUserInput!
  ): RegisterUserPayload
  register(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: RegisterInput!
  ): RegisterPayload
  login(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: LoginInput!
  ): LoginPayload
}

"""An object with a globally unique `ID`."""
interface Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
}

type Player implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  name: String
  playerId: String!
  appearsIn: String
}

"""
A condition to be used against `Player` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input PlayerCondition {
  """Checks for equality with the object’s `playerId` field."""
  playerId: String
}

"""An input for mutations affecting `Player`"""
input PlayerInput {
  name: String
  playerId: String!
  appearsIn: String
}

"""
Represents an update to a `Player`. Fields that are set will be updated.
"""
input PlayerPatch {
  name: String
  playerId: String
  appearsIn: String
}

"""Methods to use when ordering `Player`."""
enum PlayersOrderBy {
  NATURAL
  PLAYER_ID_ASC
  PLAYER_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

type PlayerStat implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  replayId: String!
  playerName: String!
  playerId: String
  score: Int
  goals: Int
  assists: Int
  saves: Int
  shots: Int
  boostUsage: BigFloat
  smallBoosts: BigFloat
  largeBoosts: BigFloat
  wastedCollection: BigFloat
  wastedUsage: BigFloat
  timeFullBoost: BigFloat
  timeLowBoost: BigFloat
  timeNoBoost: BigFloat
  numStolenBoosts: Int
  averageBoostLevel: BigFloat
  wastedBig: BigFloat
  wastedSmall: BigFloat
  ballHitForward: BigFloat
  ballHitBackward: BigFloat
  timeClosestToBall: BigFloat
  timeCloseToBall: BigFloat
  timeClosestToTeamCenter: BigFloat
  possessionTime: BigFloat
  turnovers: BigFloat
  turnoversOnMyHalf: BigFloat
  turnoversOnTheirHalf: BigFloat
  timeLowInAir: BigFloat
  timeHighInAir: BigFloat
  timeInDefendingHalf: BigFloat
  timeInAttackingHalf: BigFloat
  timeInDefendingThird: BigFloat
  timeInNeutralThird: BigFloat
  timeInAttackingThird: BigFloat
  timeBehindBall: BigFloat
  timeInFrontBall: BigFloat
  timeNearWall: BigFloat
  timeInCorner: BigFloat
  averageSpeed: BigFloat
  averageHitDistance: BigFloat
  totalHits: BigFloat
  totalPasses: BigFloat
  timeAtSlowSpeed: BigFloat
  timeAtSuperSonic: BigFloat
  timeAtBoostSpeed: BigFloat
  timeMostForwardPlayer: BigFloat
  timeMostBackPlayer: BigFloat
  timeBetweenPlayers: BigFloat
}

"""
A condition to be used against `PlayerStat` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input PlayerStatCondition {
  """Checks for equality with the object’s `replayId` field."""
  replayId: String
}

"""An input for mutations affecting `PlayerStat`"""
input PlayerStatInput {
  replayId: String!
  playerName: String!
  playerId: String
  score: Int
  goals: Int
  assists: Int
  saves: Int
  shots: Int
  boostUsage: BigFloat
  smallBoosts: BigFloat
  largeBoosts: BigFloat
  wastedCollection: BigFloat
  wastedUsage: BigFloat
  timeFullBoost: BigFloat
  timeLowBoost: BigFloat
  timeNoBoost: BigFloat
  numStolenBoosts: Int
  averageBoostLevel: BigFloat
  wastedBig: BigFloat
  wastedSmall: BigFloat
  ballHitForward: BigFloat
  ballHitBackward: BigFloat
  timeClosestToBall: BigFloat
  timeCloseToBall: BigFloat
  timeClosestToTeamCenter: BigFloat
  possessionTime: BigFloat
  turnovers: BigFloat
  turnoversOnMyHalf: BigFloat
  turnoversOnTheirHalf: BigFloat
  timeLowInAir: BigFloat
  timeHighInAir: BigFloat
  timeInDefendingHalf: BigFloat
  timeInAttackingHalf: BigFloat
  timeInDefendingThird: BigFloat
  timeInNeutralThird: BigFloat
  timeInAttackingThird: BigFloat
  timeBehindBall: BigFloat
  timeInFrontBall: BigFloat
  timeNearWall: BigFloat
  timeInCorner: BigFloat
  averageSpeed: BigFloat
  averageHitDistance: BigFloat
  totalHits: BigFloat
  totalPasses: BigFloat
  timeAtSlowSpeed: BigFloat
  timeAtSuperSonic: BigFloat
  timeAtBoostSpeed: BigFloat
  timeMostForwardPlayer: BigFloat
  timeMostBackPlayer: BigFloat
  timeBetweenPlayers: BigFloat
}

"""
Represents an update to a `PlayerStat`. Fields that are set will be updated.
"""
input PlayerStatPatch {
  replayId: String
  playerName: String
  playerId: String
  score: Int
  goals: Int
  assists: Int
  saves: Int
  shots: Int
  boostUsage: BigFloat
  smallBoosts: BigFloat
  largeBoosts: BigFloat
  wastedCollection: BigFloat
  wastedUsage: BigFloat
  timeFullBoost: BigFloat
  timeLowBoost: BigFloat
  timeNoBoost: BigFloat
  numStolenBoosts: Int
  averageBoostLevel: BigFloat
  wastedBig: BigFloat
  wastedSmall: BigFloat
  ballHitForward: BigFloat
  ballHitBackward: BigFloat
  timeClosestToBall: BigFloat
  timeCloseToBall: BigFloat
  timeClosestToTeamCenter: BigFloat
  possessionTime: BigFloat
  turnovers: BigFloat
  turnoversOnMyHalf: BigFloat
  turnoversOnTheirHalf: BigFloat
  timeLowInAir: BigFloat
  timeHighInAir: BigFloat
  timeInDefendingHalf: BigFloat
  timeInAttackingHalf: BigFloat
  timeInDefendingThird: BigFloat
  timeInNeutralThird: BigFloat
  timeInAttackingThird: BigFloat
  timeBehindBall: BigFloat
  timeInFrontBall: BigFloat
  timeNearWall: BigFloat
  timeInCorner: BigFloat
  averageSpeed: BigFloat
  averageHitDistance: BigFloat
  totalHits: BigFloat
  totalPasses: BigFloat
  timeAtSlowSpeed: BigFloat
  timeAtSuperSonic: BigFloat
  timeAtBoostSpeed: BigFloat
  timeMostForwardPlayer: BigFloat
  timeMostBackPlayer: BigFloat
  timeBetweenPlayers: BigFloat
}

"""Methods to use when ordering `PlayerStat`."""
enum PlayerStatsOrderBy {
  NATURAL
  REPLAY_ID_ASC
  REPLAY_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""The root query type which gives access points into the data universe."""
type Query implements Node {
  """
  Exposes the root query type nested one level down. This is helpful for Relay 1
  which can only query top level fields if they are in a particular form.
  """
  query: Query!

  """
  The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`.
  """
  nodeId: ID!

  """Fetches an object given its globally unique `ID`."""
  node(
    """The globally unique `ID`."""
    nodeId: ID!
  ): Node

  """Reads a set of `UserAccount`."""
  allUserAccountsList(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `UserAccount`."""
    orderBy: [UserAccountsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserAccountCondition
  ): [UserAccount!]

  """Reads a set of `Meta`."""
  allMetasList(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Meta`."""
    orderBy: [MetasOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MetaCondition
  ): [Meta!]

  """Reads a set of `Player`."""
  allPlayersList(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Player`."""
    orderBy: [PlayersOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PlayerCondition
  ): [Player!]

  """Reads a set of `PlayerStat`."""
  allPlayerStatsList(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `PlayerStat`."""
    orderBy: [PlayerStatsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PlayerStatCondition
  ): [PlayerStat!]
  userAccountByUserId(userId: UUID!): UserAccount
  userAccountByUsername(username: String!): UserAccount
  metaByReplayId(replayId: String!): Meta
  playerByPlayerId(playerId: String!): Player
  playerStatByReplayIdAndPlayerName(replayId: String!, playerName: String!): PlayerStat

  """Returns the user currently in the session."""
  currentPerson: UserAccount

  """Reads a single `UserAccount` using its globally unique `ID`."""
  userAccount(
    """
    The globally unique `ID` to be used in selecting a single `UserAccount`.
    """
    nodeId: ID!
  ): UserAccount

  """Reads a single `Meta` using its globally unique `ID`."""
  meta(
    """The globally unique `ID` to be used in selecting a single `Meta`."""
    nodeId: ID!
  ): Meta

  """Reads a single `Player` using its globally unique `ID`."""
  player(
    """The globally unique `ID` to be used in selecting a single `Player`."""
    nodeId: ID!
  ): Player

  """Reads a single `PlayerStat` using its globally unique `ID`."""
  playerStat(
    """
    The globally unique `ID` to be used in selecting a single `PlayerStat`.
    """
    nodeId: ID!
  ): PlayerStat
}

input RegisterInput {
  username: String!
  email: String!
  password: String!
}

type RegisterPayload {
  user: UserAccount!
}

"""All input for the `registerUser` mutation."""
input RegisterUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  username: String!
  email: String!
  password: String!
}

"""The output of our `registerUser` mutation."""
type RegisterUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  userAccount: UserAccount

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.

#### Live Queries

Live query fields are differentiated by containing `(live)` at the end of their
description, they are added for each field in the `Query` type. When you
subscribe to a live query field, the selection set will be evaluated and sent to
the client, and then most things\* that would cause the output of the selection
set to change will trigger the selection set to be re-evaluated and the results
to be re-sent to the client.

_(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_

Live queries can be very expensive, so try and keep them small and focussed.

#### Events

Event fields will run their selection set when, and only when, the specified
server-side event occurs. This makes them a lot more efficient than Live
Queries, but it is still recommended that you keep payloads fairly small.
"""
type Subscription {
  """
  Exposes the root query type nested one level down. This is helpful for Relay 1
  which can only query top level fields if they are in a particular form. (live)
  """
  query: Query!

  """
  The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`. (live)
  """
  nodeId: ID!

  """Fetches an object given its globally unique `ID`. (live)"""
  node(
    """The globally unique `ID`."""
    nodeId: ID!
  ): Node

  """Reads a set of `UserAccount`. (live)"""
  allUserAccountsList(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `UserAccount`."""
    orderBy: [UserAccountsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserAccountCondition
  ): [UserAccount!]

  """Reads a set of `Meta`. (live)"""
  allMetasList(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Meta`."""
    orderBy: [MetasOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MetaCondition
  ): [Meta!]

  """Reads a set of `Player`. (live)"""
  allPlayersList(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Player`."""
    orderBy: [PlayersOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PlayerCondition
  ): [Player!]

  """Reads a set of `PlayerStat`. (live)"""
  allPlayerStatsList(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `PlayerStat`."""
    orderBy: [PlayerStatsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PlayerStatCondition
  ): [PlayerStat!]

  """ (live)"""
  userAccountByUserId(userId: UUID!): UserAccount

  """ (live)"""
  userAccountByUsername(username: String!): UserAccount

  """ (live)"""
  metaByReplayId(replayId: String!): Meta

  """ (live)"""
  playerByPlayerId(playerId: String!): Player

  """ (live)"""
  playerStatByReplayIdAndPlayerName(replayId: String!, playerName: String!): PlayerStat

  """Returns the user currently in the session. (live)"""
  currentPerson: UserAccount

  """Reads a single `UserAccount` using its globally unique `ID`. (live)"""
  userAccount(
    """
    The globally unique `ID` to be used in selecting a single `UserAccount`.
    """
    nodeId: ID!
  ): UserAccount

  """Reads a single `Meta` using its globally unique `ID`. (live)"""
  meta(
    """The globally unique `ID` to be used in selecting a single `Meta`."""
    nodeId: ID!
  ): Meta

  """Reads a single `Player` using its globally unique `ID`. (live)"""
  player(
    """The globally unique `ID` to be used in selecting a single `Player`."""
    nodeId: ID!
  ): Player

  """Reads a single `PlayerStat` using its globally unique `ID`. (live)"""
  playerStat(
    """
    The globally unique `ID` to be used in selecting a single `PlayerStat`.
    """
    nodeId: ID!
  ): PlayerStat
}

"""All input for the `updateMetaByReplayId` mutation."""
input UpdateMetaByReplayIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Meta` being updated.
  """
  metaPatch: MetaPatch!
  replayId: String!
}

"""All input for the `updateMeta` mutation."""
input UpdateMetaInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Meta` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Meta` being updated.
  """
  metaPatch: MetaPatch!
}

"""The output of our update `Meta` mutation."""
type UpdateMetaPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Meta` that was updated by this mutation."""
  meta: Meta

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `updatePlayerByPlayerId` mutation."""
input UpdatePlayerByPlayerIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Player` being updated.
  """
  playerPatch: PlayerPatch!
  playerId: String!
}

"""All input for the `updatePlayer` mutation."""
input UpdatePlayerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Player` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Player` being updated.
  """
  playerPatch: PlayerPatch!
}

"""The output of our update `Player` mutation."""
type UpdatePlayerPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Player` that was updated by this mutation."""
  player: Player

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `updatePlayerStatByReplayIdAndPlayerName` mutation."""
input UpdatePlayerStatByReplayIdAndPlayerNameInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `PlayerStat` being updated.
  """
  playerStatPatch: PlayerStatPatch!
  replayId: String!
  playerName: String!
}

"""All input for the `updatePlayerStat` mutation."""
input UpdatePlayerStatInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `PlayerStat` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `PlayerStat` being updated.
  """
  playerStatPatch: PlayerStatPatch!
}

"""The output of our update `PlayerStat` mutation."""
type UpdatePlayerStatPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `PlayerStat` that was updated by this mutation."""
  playerStat: PlayerStat

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `updateUserAccountByUserId` mutation."""
input UpdateUserAccountByUserIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `UserAccount` being updated.
  """
  userAccountPatch: UserAccountPatch!

  """Primary unique identifier for a user. Autogenerated."""
  userId: UUID!
}

"""All input for the `updateUserAccountByUsername` mutation."""
input UpdateUserAccountByUsernameInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `UserAccount` being updated.
  """
  userAccountPatch: UserAccountPatch!

  """The user’s username. Can be null."""
  username: String!
}

"""All input for the `updateUserAccount` mutation."""
input UpdateUserAccountInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `UserAccount` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `UserAccount` being updated.
  """
  userAccountPatch: UserAccountPatch!
}

"""The output of our update `UserAccount` mutation."""
type UpdateUserAccountPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `UserAccount` that was updated by this mutation."""
  userAccount: UserAccount

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""A user’s core account"""
type UserAccount implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """Primary unique identifier for a user. Autogenerated."""
  userId: UUID!

  """The user’s username. Can be null."""
  username: String

  """The status of users confirmed email."""
  emailConfirmed: Boolean!

  """The users role."""
  roles: String!

  """The time this person was created."""
  createdAt: Datetime

  """The time this person was last updated."""
  updatedAt: Datetime
}

"""
A condition to be used against `UserAccount` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input UserAccountCondition {
  """Checks for equality with the object’s `userId` field."""
  userId: UUID

  """Checks for equality with the object’s `username` field."""
  username: String
}

"""An input for mutations affecting `UserAccount`"""
input UserAccountInput {
  """Primary unique identifier for a user. Autogenerated."""
  userId: UUID

  """The user’s username. Can be null."""
  username: String

  """The status of users confirmed email."""
  emailConfirmed: Boolean

  """The users role."""
  roles: String

  """The time this person was created."""
  createdAt: Datetime

  """The time this person was last updated."""
  updatedAt: Datetime
}

"""
Represents an update to a `UserAccount`. Fields that are set will be updated.
"""
input UserAccountPatch {
  """Primary unique identifier for a user. Autogenerated."""
  userId: UUID

  """The user’s username. Can be null."""
  username: String

  """The status of users confirmed email."""
  emailConfirmed: Boolean

  """The users role."""
  roles: String

  """The time this person was created."""
  createdAt: Datetime

  """The time this person was last updated."""
  updatedAt: Datetime
}

"""Methods to use when ordering `UserAccount`."""
enum UserAccountsOrderBy {
  NATURAL
  USER_ID_ASC
  USER_ID_DESC
  USERNAME_ASC
  USERNAME_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A universally unique identifier as defined by [RFC 4122](https://tools.ietf.org/html/rfc4122).
"""
scalar UUID
